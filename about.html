<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <meta charset="utf-8"/> <title>Radiance</title> <meta name="viewport" content="width=device-width"/> <meta name="description" content="A web application environment."/> <meta name="author" content="Nicolas Hafner &lt;shinmera@tymoon.eu&gt;"/> <style type="text/css"> body{
          max-width: 1024px;
          margin: 0 auto 0 auto;
          font-family: sans-serif;
          color: #333333;
          font-size: 14pt;
          padding: 5px;
      }
      body>header{
          display:flex;
          align-items: center;
          justify-content: center;
          flex-direction: column;
          max-width: 100%;
          text-align: center;
      }
      body>header img{
          max-width: 50%;
      }
      img{
          max-width: 100%;
          max-height: 100%;
      }
      code{
          font-family: Consolas, Inconsolata, monospace;
      }
      a{
          text-decoration: none;
          color: #0055AA;
      }
      a img{
          border: none;
      }
      #documentation{
          text-align: justify;
      }
      #documentation pre{
          margin-left: 20px;
          overflow: auto;
      }
      #documentation img{
          margin: 5px;
      }
      #symbol-index>ul{
          list-style: none;
          padding: 0;
      }
      #symbol-index .package>ul{
          list-style: none;
          padding: 0 0 0 10px;
      }
      #symbol-index .package .nicknames{
          font-weight: normal;
      }
      #symbol-index .package h4{
          display: inline-block;
          margin: 0;
      }
      #symbol-index .package article{
          margin: 0 0 15px 0;
      }
      #symbol-index .package article header{
          font-size: 1.2em;
          font-weight: normal;
      }
      #symbol-index .package .name{
          margin-right: 5px;
      }
      #symbol-index .package .docstring{
          margin: 0 0 0 15px;
          white-space: pre-wrap;
          font-size: 12pt;
      }
      @media (max-width: 800px){
          body{font-size: 12pt;}
      } </style> </head> <body> <header> <h1>radiance</h1> <span class="version"/> <p class="description">A web application environment.</p> </header> <main> <article id="documentation">  <div><h2>About Radiance</h2> <p>Radiance is a web application environment, which is sort of like a web framework, but more general, more flexible. It should let you write personal websites and generally deployable applications easily and in such a way that they can be used on practically any setup without having to undergo special adaptations.</p> <h2>Getting It</h2> <p>Radiance and associated modules and applications are distributed via Quicklisp in a separate dist. To install Radiance, do:</p> <pre><code>(ql-dist:install-dist &quot;http://dist.tymoon.eu/shirakumo.txt&quot;)
(ql:quickload :radiance)
</code></pre> <p>From there on out you should be able to load and use any kind of Radiance module like <a href="https://github.com/Shirakumo/purplish">Purplish</a> directly via Quicklisp's <code>quickload</code>.</p> <h2>A Lengthy and In-Depth Example</h2> <p>You can find a tutorial that introduces Radiance and most of the important concepts, and explores how to write a web application in general, <a href="https://github.com/Shirakumo/radiance-tutorial/blob/master/Part%200.md">here</a>. It should give you a good feeling for how to go about things, and give you pointers about where to look if you need a particular feature. In the last part it'll also go into the actual setup and deployment of a Radiance installation on a production server.</p> <h2>A Simple Example</h2> <p>The most basic thing you most likely want to do is serve some kind of HTML. So let's work towards that and gradually extend it. Before we can begin, we need to start up Radiance.</p> <pre><code><span class="code"><span class="paren1">(<span class="code">ql:quickload <span class="keyword">:radiance</span></span>)</span>
<span class="paren1">(<span class="code">radiance:startup</span>)</span></span></code></pre> <p>If this is your first time setting up Radiance, you'll get a note about it using the <code>r-welcome</code> module. It should also give you a link that you can open in your browser to see a little greeting page. For now we'll just want to put up our own little page alongside it.</p> <pre><code><span class="code"><span class="paren1">(<span class="code">in-package <span class="keyword">:rad-user</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">define-page</span></i> example <span class="string">&quot;/example&quot;</span> <span class="paren2">(<span class="code"/>)</span>
  <span class="paren2">(<span class="code">setf <span class="paren3">(<span class="code">content-type <span class="special">*response*</span></span>)</span> <span class="string">&quot;text/plain&quot;</span></span>)</span> 
  <span class="string">&quot;Hi!&quot;</span></span>)</span></span></code></pre> <p>Visiting <a href="http://localhost:8080/example">localhost:8080/example</a> should now just show &quot;Hi&quot;. Rather boring indeed. So let's spit out some HTML instead. For now, we'll use <a href="http://weitz.de/cl-who/">cl-who</a> since it is very simple.</p> <pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">define-page</span></i> example <span class="string">&quot;/example&quot;</span> <span class="paren2">(<span class="code"/>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">cl-who:with-html-output-to-string</span></i> <span class="paren3">(<span class="code">o</span>)</span>
    <span class="paren3">(<span class="code">cl-who:htm
     <span class="paren4">(<span class="code"><span class="keyword">:html</span>
      <span class="paren5">(<span class="code"><span class="keyword">:head</span> <span class="paren6">(<span class="code"><span class="keyword">:title</span> <span class="string">&quot;Example Page&quot;</span></span>)</span></span>)</span>
      <span class="paren5">(<span class="code"><span class="keyword">:body</span> <span class="paren6">(<span class="code"><span class="keyword">:header</span> <span class="paren1">(<span class="code"><span class="keyword">:h1</span> <span class="string">&quot;Couldn't Be Simpler.&quot;</span></span>)</span></span>)</span>
             <span class="paren6">(<span class="code"><span class="keyword">:main</span> <span class="paren1">(<span class="code"><span class="keyword">:p</span> <span class="string">&quot;Trust me on this one.&quot;</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre> <p>A recompile and refresh later and we have some font styling going on. Next we'll probably want to add a CSS file to it to style it properly. We could serve the CSS using another page as well, but that isn't the best way to go about things in the long term.</p> <p>Let's instead look at how to create a module, which will allow us to organise things in a more orderly fashion. You can create the files for a module manually, but for now we'll settle with an automatically generated skeleton that Radiance can provide you with.</p> <pre><code><span class="code"><span class="paren1">(<span class="code">create-module <span class="string">&quot;example&quot;</span></span>)</span></span></code></pre> <p>It should return you a path on which the module resides. It should contain an ASDF system, a main lisp file, and two folders, <code>static</code> and <code>template</code>. Surprisingly enough, the <code>static</code> folder is where statically served files go, and <code>template</code> is for template documents, if you happen to use a template system.</p> <p>Let's open up the <code>example.lisp</code> and carry over our example page from it.</p> <pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">define-page</span></i> example <span class="string">&quot;/example&quot;</span> <span class="paren2">(<span class="code"/>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">cl-who:with-html-output-to-string</span></i> <span class="paren3">(<span class="code">o</span>)</span>
    <span class="paren3">(<span class="code">cl-who:htm
     <span class="paren4">(<span class="code"><span class="keyword">:html</span>
      <span class="paren5">(<span class="code"><span class="keyword">:head</span> <span class="paren6">(<span class="code"><span class="keyword">:title</span> <span class="string">&quot;Example Page&quot;</span></span>)</span></span>)</span>
      <span class="paren5">(<span class="code"><span class="keyword">:body</span> <span class="paren6">(<span class="code"><span class="keyword">:header</span> <span class="paren1">(<span class="code"><span class="keyword">:h1</span> <span class="string">&quot;Couldn't Be Simpler.&quot;</span></span>)</span></span>)</span>
             <span class="paren6">(<span class="code"><span class="keyword">:main</span> <span class="paren1">(<span class="code"><span class="keyword">:p</span> <span class="string">&quot;Trust me on this one.&quot;</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre> <p>Pages are identified by a name symbol. Since we now have our own module, and thus our own package, the example symbol above won't be the same as the one we've used before. We'll just have to remove the page in the <code>rad-user</code> package to avoid the clash.</p> <pre><code><span class="code"><span class="paren1">(<span class="code">remove-page 'rad-user::example</span>)</span></span></code></pre> <p>Next let's create a simple CSS file to spruce things up a little. The file will be <code>example.css</code> placed in the <code>static</code> folder. Here's a sample CSS if you don't want to write your own.</p> <pre><code>body{
    font-family: sans-serif;
    font-size: 12pt;
    background: #EEE;
}

header{
    text-align: center;
}

main{
    width: 800px;
    margin: 0 auto 0 auto;
    background: #FFF;
    padding: 10px;
    border: 1px solid #BBB;
    border-radius: 5px;
}</code></pre> <p>Next we need to modify our HTML to actually link to the style sheet. In order to get the address to the stylesheet we'll have to make use of Radiance's routing system. Don't worry though, it's not much of a hassle.</p> <pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">define-page</span></i> example <span class="string">&quot;/example&quot;</span> <span class="paren2">(<span class="code"/>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">cl-who:with-html-output-to-string</span></i> <span class="paren3">(<span class="code">o</span>)</span>
    <span class="paren3">(<span class="code">cl-who:htm
     <span class="paren4">(<span class="code"><span class="keyword">:html</span>
      <span class="paren5">(<span class="code"><span class="keyword">:head</span> <span class="paren6">(<span class="code"><span class="keyword">:title</span> <span class="string">&quot;Example Page&quot;</span></span>)</span>
             <span class="paren6">(<span class="code"><span class="keyword">:link</span> <span class="keyword">:rel</span> <span class="string">&quot;stylesheet&quot;</span> <span class="keyword">:type</span> <span class="string">&quot;text/css&quot;</span> 
                    <span class="keyword">:href</span> <span class="paren1">(<span class="code">uri-to-url <span class="string">&quot;/static/example/example.css&quot;</span> <span class="keyword">:representation</span> <span class="keyword">:external</span></span>)</span></span>)</span></span>)</span>
      <span class="paren5">(<span class="code"><span class="keyword">:body</span> <span class="paren6">(<span class="code"><span class="keyword">:header</span> <span class="paren1">(<span class="code"><span class="keyword">:h1</span> <span class="string">&quot;Couldn't Be Simpler.&quot;</span></span>)</span></span>)</span>
             <span class="paren6">(<span class="code"><span class="keyword">:main</span> <span class="paren1">(<span class="code"><span class="keyword">:p</span> <span class="string">&quot;Trust me on this one.&quot;</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre> <p>Refresh the page, and voil√†, now it's got some pizzazz to it too. You'll probably want an explanation for the whole <code>uri-to-url</code> business. Explaining it in full is handled by the sections following this one, but the gist of it is that it ensures that the link to the static file is properly resolved under any setup.</p> <h2>1. Radiance Concepts &amp; Parts</h2> <h3>1.1 URI</h3> <p>One of the most central concepts in Radiance is that of a URI. A URI is an object that consists of a list of domains, an optional port number, and a path (see <code>uri</code>). It is essentially a stripped down version of a general URI, and as such doesn't include a schema, query, or fragment part. Another important difference is that the <code>domains</code> URIs are used at several points throughout the framework, both to capture locations and to handle dispatch matching.</p> <p>Note that URIs are mutable. This is important for performance, as URI modifications have to happen in several parts that lie on the critical path. However, in the usual case it is not expected that URIs are modified outside of a few select functions. Modifying a URI's parts in unexpected ways may lead to strange behaviour.</p> <p>URIs have a unique string representation and can be serialised to string and parsed back into a full URI object again. URIs can also be dumped to FASL files as literals, so emitting them from macros is fine. The syntax for a URI is as follows:</p> <pre><code>URI     ::= DOMAINS? (':' PORT)? '/' PATH?
DOMAINS ::= DOMAIN ('.' DOMAIN)*
DOMAIN  ::= ('a'..'Z' | '0'..'9' | '-')
PORT    ::= ('0'..'9'){1, 5}
PATH    ::= .*</code></pre> <p>You can use <code>uri-to-url</code> to turn a URI into a concrete URL. Reversal, encoding, and proper formatting of all the parts is handled for you automatically there.</p> <p>See <code>uri</code>, <code>domains</code>, <code>port</code>, <code>path</code>, <code>matcher</code>, <code>uri-string</code>, <code>make-uri</code>, <code>make-url</code>, <code>ensure-uri</code>, <code>copy-uri</code>, <code>parse-uri</code>, <code>uri&lt;</code>, <code>uri&gt;</code>, <code>uri=</code>, <code>uri-matches</code>, <code>merge-uris</code>, <code>represent-uri</code>, <code>uri-to-url</code>.</p> <h3>1.2 Request and Response</h3> <p>In order to encapsulate the data that is sent to  and from, we have the idea of a Request (<code>request</code>) and Response (<code>response</code>) object. The Request object holds the URI that represents to which location the request goes, and all the data contained in the HTTP payload like post, get, header, and cookie variables. The Response object holds the return-code, headers, cookies, and the actual body data.</p> <p>During the processing of a request, these two objects must always be present and bound to the <code>*request*</code> and <code>*response*</code> variables. They encapsulate a lot of very vital information that is necessary to generate dynamic pages. Additionally, the Request contains an opaque <code>data</code> table in which you can store arbitrary data. This is useful when you need to exchange pieces of information between individual parts of the system that may be reached during the request execution.</p> <p>Requests don't necessarily have to come from the HTTP server. In order to test things you can also construct a request yourself and send it out programmatically. Whatever the case, the primary interface to dispatch a request is called <code>request</code>. This will construct a Request and Response object for you and appropriately handle the URI. If you want to do that yourself and <em>really</em> just send out a complete Request object, you can use <code>execute-request</code>.</p> <p>For the actual handling of a request, see dispatchers, pages, and API endpoints.</p> <p>See <code>*request*</code>, <code>*response*</code>, <code>*default-external-format*</code>, <code>*default-content-type*</code>, <code>request</code>, <code>uri</code>, <code>http-method</code>, <code>headers</code>, <code>post-data</code>, <code>get-data</code>, <code>cookies</code>, <code>user-agent</code>, <code>referer</code>, <code>domain</code>, <code>remote</code>, <code>data</code>, <code>issue-time</code>, <code>response</code>, <code>data</code>, <code>return-code</code>, <code>content-type</code>, <code>external-format</code>, <code>headers</code>, <code>cookies</code>, <code>cookie</code>, <code>name</code>, <code>value</code>, <code>domain</code>, <code>path</code>, <code>expires</code>, <code>http-only</code>, <code>secure</code>, <code>cookie-header</code>, <code>cookie</code>, <code>get-var</code>, <code>post-var</code>, <code>post/get</code>, <code>header</code>, <code>file</code>, <code>redirect</code>, <code>serve-file</code>, <code>request-run-time</code>, <code>*debugger*</code>, <code>handle-condition</code>, <code>render-error-page</code>, <code>execute-request</code>, <code>set-data</code>, <code>request</code></p> <h3>1.3 Route</h3> <p>Before a Request can be dispatched on, it goes through something called the routing system. Unlike in other frameworks, where 'routes' designate what handles a request, in Radiance a Route (<code>route</code>) is a form of URI translator. This part of the system is what's responsible for creating and upholding two &quot;universes&quot;, an internal and an external one.</p> <p>The internal universe is the one actual web applications live in. The external universe is the one the HTTP server and a user of the website lives in. This distinction is necessary in order to allow you to, one one hand, write web applications without having to worry about what a potential setup on a server might look like at some point. You don't have to worry about what kind of domain, port, path setup may be necessary to run your application. On the other hand, it allows you, as a webadmin, to customise and run the system to your exact desires without fear of breaking things.</p> <p>This all is facilitated by routes, of which there are two kinds: mapping, and reversal routes. Mapping routes are responsible for turning a URI from the external universe into one of the internal universe. Usually this involves cutting away the top-level domain and perhaps doing a mapping of subdomains. Reversal routes do the opposite-- they go from the internal universe to the external. This is necessary in order to make links in your served pages refer to resources that are actually accessible from the outside. Usually this involves reversing the subdomain mapping and adding the top-level domain again.</p> <p>Routes can perform arbitrary work. At the most basic level, they are merely functions that modify a URI in some fashion. This allows you to create a very flexible system that should be powerful enough to accommodate to all of your needs as an administrator. As an application writer, you just need to make sure to use <code>external-uri</code> or <code>uri-to-url</code> on all of the links that you put into your pages.</p> <p>See <code>route</code>, <code>name</code>, <code>direction</code>, <code>priority</code>, <code>translator</code>, <code>route</code>, <code>remove-route</code>, <code>list-routes</code>, <code>define-route</code>, <code>define-matching-route</code>, <code>define-target-route</code>, <code>define-string-route</code>, <code>internal-uri</code>, <code>external-uri</code></p> <h3>1.4 URI Dispatcher</h3> <p>Finally we come to the part that actually generates content for a request. URI dispatchers are a subclass of URI that also carry a name, a function, and a priority. The live in a priority-sorted list, which is processed whenever a request arrives. The Request's URI is matched against each dispatcher. The function of the first dispatcher that matches is then executed.</p> <p>And that's it. The dispatcher's function is responsible for setting the necessary values in the Response object to deliver the page content. In order to do this it can either directly set the <code>data</code> field of the Response object, or you can return an appropriate value from the function. Radiance only accepts four types of values: <code><a href="http://l1sp.org/cl/stream">stream</a></code>, <code><a href="http://l1sp.org/cl/pathname">pathname</a></code>, <code><a href="http://l1sp.org/cl/string">string</a></code>, and <code>(<a href="http://l1sp.org/cl/array">array</a> (<a href="http://l1sp.org/cl/unsigned-byte">unsigned-byte</a> 8))</code>.</p> <p>If a URI dispatcher does not have an explicit priority number, its priority over others is determined by the specificity of the URI. See the URI sorting function <code>uri&gt;</code> for an explanation on how exactly this is calculated.</p> <p>See <code>uri-dispatcher</code>, <code>name</code>, <code>dispatch-function</code>, <code>priority</code>, <code>uri-dispatcher</code>, <code>remove-uri-dispatcher</code>, <code>list-uri-dispatchers</code>, <code>uri-dispatcher&gt;</code>, <code>define-uri-dispatcher</code>, <code>dispatch</code></p> <h3>1.5 Page</h3> <p>Pages are what you will likely use to define your actual content serving functions. However, a page is just a uri-dispatcher with some extra functionality in the definition macro that makes things easier on you. Most notably are the extensible options, for which you can find an explanation below.</p> <p>There are a couple of default pages set up by Radiance itself. First there's the <code>favicon</code> and <code>robots</code> pages, which simply serve the respective files from Radiance's <code>static/</code> directory. You'll probably want to either provide your own pages for that or update the files on your production server.</p> <p>Then there's the <code>static</code> page, which is responsible for serving static contents for all web applications and modules. It should be active on any domain and always on the path <code>/static/...</code> where <code>...</code> must have a form where the first directory is the name of a module, and the rest is a path within that module's <code>static/</code> directory. This allows you to always be able to refer to static files like CSS, JS, and images through a common path.</p> <p>Finally there's the <code>api</code> page, which is responsible for handling the dispatch of API endpoints, which are explained in the following section. The page acts similarly to the static one by capturing the <code>/api/...</code> path on all domains.</p> <p>See <code>page</code>, <code>remove-page</code>, <code>define-page</code></p> <h3>1.6 API Endpoint</h3> <p>Radiance provides integrated support for REST API definition. This is not just a tacked-on feature, but rather because most modern applications want to provide an API of some kind, and because Radiance advises a certain way of writing your applications that necessarily involves API endpoints.</p> <p>Conceptually, API endpoints are functions that are callable through a browser request. Their response is then serialised to a format that is readable by the requester, whatever that may be. Important to remember however is that API endpoints should be usable by both users and programs. Radiance encourages this because usually any kind of action that can be performed programmatically through an API will also have to be performed by the user in some way. In order to avoid duplication, the two can be conflated.</p> <p>As such, usually any kind of data modification action should be provided through an API endpoint that reacts slightly differently depending on whether a user or an application requests it. In the case of a user, it should usually redirect back to an appropriate page, and in the case of an application it should provide a data payload in a readable format.</p> <p>The first part of all of this is the API format system, which is responsible for serialising data to some specified format. By default only an S-expression based format is supplied, but a contrib to get JSON output can easily be loaded.</p> <p>The second part is the specification of the <code>browser</code> POST/GET parameter. If that parameter contains the exact string <code>&quot;true&quot;</code>, then the API request is treated as coming from a user, and thus a redirect rather than a data payload should be outputted.</p> <p>Your application should make use of those things in order to provide a properly integrated api. Now, an actual endpoint definition is composed of a name, a raw function, a lambda-list describing the arguments of the function, and a request parsing function. Typically for your arguments, only required and optional arguments make sense. After all, an HTTP request only has &quot;keyword arguments&quot; that it can provide, and those can either be present or missing.</p> <p>The name of an API endpoint also serves as the identifier that tells you where you can reach it. API endpoints live on the <code>/api/</code> path, followed by the name of the endpoint. As such, you are responsible for prefixing your endpoints with the name of your module or application in order to avoid accidentally tripping over other endpoints. This is unlike in uri dispatchers, because API endpoints have to match exactly and don't allow any ambiguity or processing of the path. Thus every endpoint must have a unique path, which can also immediately serve as the name.</p> <p>The raw function is the function that the API provides an interface for. It is responsible for performing the requested action and returning the appropriate data as described above. For returning formatted API data, see <code>api-output</code>. For redirecting in the case of a browser request, see <code>redirect</code>.</p> <p>Finally, the request parsing function is responsible for taking a Request object, extracting the arguments the function needs from it, and finally calling that function with the appropriate arguments-- if possible. The parsing function may signal an <code>api-argument-missing</code> error if a required argument is missing. Superfluous arguments should be ignored.</p> <p>You can also programmatically call an API endpoint using <code>call-api</code>, or simulate a Request call with <code>call-api-request</code>, without having to go through the whole URI dispatch mechanism.</p> <p>Similarly to pages, API endpoint definitions also accept extensible options that make definition simpler. See the following section for an explanation of options.</p> <p>See <code>api</code>, <code>*default-api-format*</code>, <code>*serialize-fallback*</code>, <code>api-format</code>, <code>remove-api-format</code>, <code>list-api-formats</code>, <code>define-api-format</code>, <code>api-output</code>, <code>api-serialize</code>, <code>api-endpoint</code>, <code>remove-api-endpoint</code>, <code>list-api-endpoints</code>, <code>api-endpoint</code>, <code>name</code>, <code>handler</code>, <code>argslist</code>, <code>request-handler</code>, <code>call-api-request</code>, <code>call-api</code>, <code>define-api</code></p> <h3>1.7 Options</h3> <p>Options are a way of providing an extensible definition macro. This is useful when a framework provides a common way of defining something, but other parts may want to provide extensions to that in order to make common operations shorter. For example, a common task is to restrict a page or API endpoint to people who have the required access credentials.</p> <p>In order to facilitate this, Radiance provides a rather generic options mechanism. Options are divided up by an option type that designates to which definition macro the option belongs. Radiance provides the <code>api</code> and <code>page</code> option types out of the box.</p> <p>Each option has a keyword for a name and an expander function that must accept a number of arguments, depending on the option type. Always provided as arguments are the name of the thing being defined, the list of body forms of the definition, and a final, optional, value that was provided to the option in the options list, if it was mentioned at all. This expansion function is then responsible for transforming the body forms of the definition macro in some way. It can also emit a second form that is placed outside of the definition itself, in order to allow setting up the environment in some manner.</p> <p>See <code>option</code>, <code>option-type</code>, <code>name</code>, <code>expander</code>, <code>option</code>, <code>remove-option</code>, <code>list-options</code>, <code>define-option</code>, <code>expand-options</code></p> <h3>1.8 Module</h3> <p>The concept of a module is essential to Radiance. It serves as the representation of a &quot;part&quot; of the whole. On a technical level, a module is a package that has special metadata attached to it. It is provided by the <code>modularize</code> system and is used to facilitate hooks and triggers, interfaces, and the tracking of a few other pieces of information.</p> <p>What this means for you is that instead of a standard <code><a href="http://l1sp.org/cl/defpackage">defpackage</a></code> you should use a <code>define-module</code> form to define your primary package. The syntax is the same as <code><a href="http://l1sp.org/cl/defpackage">defpackage</a></code>, but includes some extra options like <code>:domain</code>, which allows you to specify the primary domain on which this module should operate (if any).</p> <p>The module system also allows the tying of an ASDF system to a module. If that is done, then the ASDF system becomes a &quot;virtual module&quot;. In order to do this, you must add three options to your system definition:</p> <pre><code><span class="code">:defsystem-depends-on <span class="paren1">(<span class="code"><span class="keyword">:radiance</span></span>)</span>
:class &quot;radiance:virtual-module&quot;
:module-name &quot;MY-MODULE&quot;</span></code></pre> <p>This allows Radiance to identify and associate ASDF system information to your module. For automated creation of the necessary system and module definitions for a new module, see <code>create-module</code>.</p> <p>See <code>virtual-module</code>, <code>virtual-module-name</code>, <code>define-module</code>, <code>define-module-extension</code>, <code>delete-module</code>, <code>module</code>, <code>module-p</code>, <code>module-storage</code>, <code>module-storage-remove</code>, <code>module-identifier</code>, <code>module-name</code>, <code>current-module</code>, <code>module-domain</code>, <code>module-permissions</code>, <code>module-dependencies</code>, <code>module-required-interfaces</code>, <code>module-required-systems</code>, <code>module-pages</code>, <code>module-api-endpoints</code>, <code>describe-module</code>, <code>find-modules-directory</code>, <code>*modules-directory*</code>, <code>create-module</code></p> <h3>1.9 Hooks</h3> <p>One of the mechanisms that Radiance provides to allow integrating modules into each other is hooks. Hooks allow you to run an arbitrary function in response to some kind of event. For example, a forum software might set up a hook that is triggered whenever a new post is created. An extension could then define a trigger on that hook that performs additional tasks.</p> <p>A hook can have an arbitrary number of triggers defined on it, but you should ensure that a trigger does not take too long, as triggering a hook is a blocking operation that won't finish until all of the triggers have completed. As such, a long-running trigger operation might delay a request response for too long.</p> <p>Sometimes hooks should function more like switches, where they can be &quot;on&quot; for a long time, until they're turned &quot;off&quot; again later. If new triggers are defined during that time, they should be called automatically. This is what the <code>define-hook-switch</code> facilitates. It produces two hooks. Once the first one has been triggered, any trigger that is defined on it later is called automatically until the second hook is triggered. This allows triggers on hooks like <code>server-start</code> to function properly even if the trigger is only defined after the server has already been started.</p> <p>See <code>list-hooks</code>, <code>define-hook</code>, <code>remove-hook</code>, <code>define-trigger</code>, <code>remove-trigger</code>, <code>trigger</code>, <code>define-hook-switch</code></p> <h3>1.10 Interface</h3> <p>In order to avoid becoming monolithic, and in order to allow extensible backends, Radiance includes an interface system. In the most general sense, an interface provides a promise as to how some functions, macros, variables, etc. should work, but does not actually implement them. The actual functionality that makes everything that the interface outlines work is pushed off to an implementation. This allows users to code against an interface and make use of its provided functionality, without tying themselves to any particular backend.</p> <p>For a concrete example, let's say there's an interface for a database. This is sensible, since there are many different kinds of databases, that all offer many differing ways of interaction, but still all also offer some very common operations: storing data, retrieving data, and modifying the data. Thus we create an interface that offers these common operations. It is then up to an implementation for a specific kind of database to make the actual operations work. As an application writer, you can then make use of the database interface, and with it, make your application automatically work with lots of different databases.</p> <p>Aside from giving application writers an advantage, the decoupling that the interfaces provide also mean that a system administrator can write their own implementation with relative ease, should their particular requirements not be met by existing implementations. Thanks to the opaqueness of the interfaces, an implementation can both provide a bridge to something that runs in the lisp process, and something that is completely external. This leaves a lot of choice open for the administrator of a production system to allow them to pick exactly what they need.</p> <p>In practise, interfaces are special kinds of modules, and thus special kinds of packages. As part of their definition, they include a series of definitions for other bindings like functions, variables, etc. Since it is a package, as a user you can use the interface's components just like you would use anything else in any other package. There is no difference. As an implementation writer, you then simply redefine all the definitions that the interface outlines.</p> <p>In order to actually load a module that makes use of an interface, an implementation for the interface has to be loaded beforehand. Otherwise, macros could not work properly. Thus, in order to allow depending on interfaces in your ASDF system definition without having to refer to a specific implementation, Radiance provides an ASDF extension. This extension makes it possible to add a list like <code>(:interface :foo)</code> to your <code>:depends-on</code> list. Radiance will then resolve the interface to a concrete implementation thereof when the module is loaded.</p> <p>Radiance provides a bunch of standard interfaces. Each of those interfaces has at least one standard implementation provided by <a href="https://shirakumo.org/projects/radiance-contribs">radiance-contribs</a>. The interfaces are:</p> <ul> <li><code>ban</code><br/> Allows banning users from the site by their IP address.</li> <li><code>rate</code><br/> Allows rate limitation for access to certain resources.</li> <li><code>admin</code><br/> Provides an extensible administration site.</li> <li><code>cache</code><br/> Provides a very simple caching interface.</li> <li><code>auth</code><br/> Handles everything about authentication and login.</li> <li><code>session</code><br/> Ensures persistent sessions for users to allow tracking them.</li> <li><code>user</code><br/> Provides user accounts and permissions.</li> <li><code>profile</code><br/> Provides an extensible user profile site and user fields.</li> <li><code>server</code><br/> The interface that bridges to a server to connect Radiance with an external universe.</li> <li><code>logger</code><br/> A simple logging interface to allow printing debug and information messages.</li> <li><code>database</code><br/> A flexible database interface that allows both object-stores and relational databases as backends.</li> </ul> <p>The interfaces are described in-depth below.</p> <p>See <code>interface</code>, <code>interface-p</code>, <code>implementation</code>, <code>implements</code>, <code>reset-interface</code>, <code>define-interface-extension</code>, <code>find-implementation</code>, <code>load-implementation</code>, <code>define-interface</code>, <code>define-implement-trigger</code></p> <h3>1.11 Environment</h3> <p>In order to permit running multiple instances of Radiance with different setups on the same machine, Radiance provides what it calls an Environment system. The Environment is basically the set of configuration files for Radiance itself and all of the loaded modules. The Radiance configuration also includes the mapping of interface to chosen implementation and thus decides what should be picked if an interface is requested.</p> <p>The particular environment that is used is chosen at the latest when <code>startup</code> is called, and the earliest when a module is loaded. In the latter case, interactive restarts are provided to allow you to pick an environment. This is necessary, as otherwise Radiance won't be able to resolve the interface mapping.</p> <p>As part of the environment system, Radiance provides you with a configuration system that you can --and probably should-- use for your application. It ensures that the settings are properly multiplexed for each environment, and that the settings are always persistent. It also uses a human-readable storage format, such that the files can be read and modified without requiring any special tools.</p> <p>See <a href="https://shinmera.github.io/ubiquitous">ubiquitous</a> for the actual handling and use-instructions of the configuration storage. Just note that instead of the <code>value</code> functions, Radiance provides <code>config</code> functions.</p> <p>See <code>environment-change</code>, <code>environment</code>, <code>check-environment</code>, <code>mconfig-pathname</code>, <code>mconfig-storage</code>, <code>mconfig</code>, <code>defaulted-mconfig</code>, <code>config</code>, <code>defaulted-config</code></p> <h3>1.12 Instance Management</h3> <p>Finally, Radiance provides a standard startup and shutdown sequence that should ensure things are properly setup and readied, and afterwards cleaned up nicely again. A large part of that sequence is just ensuring that certain hooks are called in the proper order and at the appropriate times.</p> <p>While you can start a server manually by using the appropriate interface function, you should not expect applications to run properly if you do it that way. Many of them will expect certain hooks to be called in order to work properly. This is why you should always, unless you exactly know what you're doing, use <code>startup</code> and <code>shutdown</code> to manage a Radiance instance. The documentation of the two functions should explain exactly which hooks are triggered and in which order. An implementation may provide additional, unspecified definitions on symbols in the interface package, as long as said symbols are not exported.</p> <p>See <code>*startup-time*</code>, <code>uptime</code>, <code>server-start</code>, <code>server-ready</code>, <code>server-stop</code>, <code>server-shutdown</code>, <code>startup</code>, <code>startup-done</code>, <code>shutdown</code>, <code>shutdown-done</code>, <code>started-p</code></p> <h2>2. Standard Interfaces</h2> <p>These interfaces are distributed with Radiance and are part of the core package. Libraries may provide for additional interfaces, however. For implementations of standard interfaces, the following relaxations of interface definition constraints are allowed:</p> <p>The lambda-lists that contain <code><a href="http://l1sp.org/cl/&amp;key">&amp;key</a></code> arguments can be extended by further, implementation-dependant keyword arguments. Lambda-lists that contain <code><a href="http://l1sp.org/cl/&amp;optional">&amp;optional</a></code> but no <code><a href="http://l1sp.org/cl/&amp;key">&amp;key</a></code> or <code><a href="http://l1sp.org/cl/&amp;rest">&amp;rest</a></code> may be extended by further optional arguments. Lambda-lists that contain only required arguments may be extended by further optional or keyword arguments.</p> <h3>2.1 admin</h3> <p>This interface provides for an administration page. It should be used for any kind of user-configurable settings, or system information display. Note that despite being called &quot;administration&quot;, this is not intended solely for administrators of the system. The page should be usable for any user.</p> <p>The administration page is required to be able to display a categorised menu, and a panel. The panels are provided by other modules and can be added through <code>admin:define-panel</code>. Panels that give access to sensitive operations should be appropriately restricted through the <code>:access</code> option and a non-default permission. See the user interface for an explanation on the permissions.</p> <p>In order to link to the administration page, or a specific panel on it, use the <code>page</code> resource type.</p> <p>See <code>admin:list-panels</code>, <code>admin:remove-panel</code>, <code>admin:define-panel</code>, <code>admin:panel</code></p> <h3>2.2 auth</h3> <p>The authentication interface is responsible for tying a user to a request. For this reason it must provide some manner by which a user can authenticate themselves against the system. How this is done exactly is up to the implementation. The implementation must however provide a page on which the authentication process is initiated. You can get a URI to it through the <code>page</code> resource and passing <code>&quot;login&quot;</code> as argument.</p> <p>You can test for the user currently tied to the request by <code>auth:current</code>. This may also return <code>NIL</code>, in which case the user should be interpreted as being <code>&quot;anonymous&quot;</code>. See the user interface for more information.</p> <p>See <code>auth:*login-timeout*</code>, <code>auth:page</code>, <code>auth:current</code>, <code>auth:associate</code></p> <h3>2.3 ban</h3> <p>This interface provides for IP-banning. It must prevent any client connecting through a banned IP from seeing the content of the actual page they're requesting. Bans can be lifted manually or automatically after a timeout. The implementation may or may not exert additional effort to track users across IPs.</p> <p>See <code>ban:jail</code>, <code>ban:list</code>, <code>ban:jail-time</code>, <code>ban:release</code></p> <h3>2.4 cache</h3> <p>The cache interface provides for a generic caching mechanism with a customisable invalidation test. You can explicitly renew the cache by <code>cache:renew</code>. To define a cached block, simply use <code>cache:with-cache</code>, which will cause the cached value of the body to be returned if the test form evaluates to true.</p> <p>The exact manner by which the cached value is stored is up to the implementation.</p> <p>See <code>cache:get</code>, <code>cache:renew</code>, <code>cache:with-cache</code></p> <h3>2.5 database</h3> <p>This interface provides you with a data persistence layer, usually called a database. This does not have to be a relational database, but may be one. In order to preserve implementation variance, only basic database operations are supported (no joins, triggers, etc). Data types are also restricted to integers, floats, and strings. Despite these constraints, the database interface is sufficiently useful for most applications.</p> <p>Note that particular terminology is used to distance from traditional RDBMS terms: a schema is called a &quot;structure&quot;. A table is called a &quot;collection&quot;. A row is called a &quot;record&quot;.</p> <p>Performing database operations before the database is connected results in undefined behaviour. Thus, you should put your collection creation forms (<code>db:create</code>) within a trigger on <code>db:connected</code>. Radiance ensures that the database is connected while Radiance is running, so using the database interface in any page, api, or uri dispatcher definitions is completely fine.</p> <p>The functions for actually performing data storage are, intuitively enough, called <code>db:insert</code>, <code>db:remove</code>, <code>db:update</code>, <code>db:select</code>, and <code>db:iterate</code>. The behaviour thereof should be pretty much what you'd expect. See the respective docstrings for a close inspection. Also see the docstring of <code>db:create</code> for a lengthy explanation on how to create a collection and what kind of restrictions are imposed.</p> <p>The database must ensure that once a data manipulation operation has completed, the changes caused by it will be persisted across a restart of Radiance, the lisp image, or the machine, even in the case of an unforeseen crash.</p> <p>See <code>database:condition</code>, <code>database:connection-failed</code>, <code>database:connection-already-open</code>, <code>database:collection-condition</code>, <code>database:invalid-collection</code>, <code>database:collection-already-exists</code>, <code>database:invalid-field</code>, <code>database:id</code>, <code>database:ensure-id</code>, <code>database:connect</code>, <code>database:disconnect</code>, <code>database:connected-p</code>, <code>database:collections</code>, <code>database:collection-exists-p</code>, <code>database:create</code>, <code>database:structure</code>, <code>database:empty</code>, <code>database:drop</code>, <code>database:iterate</code>, <code>database:select</code>, <code>database:count</code>, <code>database:insert</code>, <code>database:remove</code>, <code>database:update</code>, <code>database:with-transaction</code>, <code>database:query</code>, <code>database:connected</code>, <code>database:disconnected</code></p> <h3>2.6 logger</h3> <p>This interface provides primitive logging functions so that you can log messages about relevant happenings in the system. The actual configuration of what gets logged where and how is up to the implementation and the administrator of the system.</p> <p>See <code>logger:log</code>, <code>logger:trace</code>, <code>logger:debug</code>, <code>logger:info</code>, <code>logger:warn</code>, <code>logger:error</code>, <code>logger:severe</code>, <code>logger:fatal</code></p> <h3>2.7 profile</h3> <p>The profile interface provides extensions to the user interface that are commonly used in applications that want users to have some kind of presence. As part of this, the interface must provide for a page on which a user's &quot;profile&quot; can be displayed. The profile must show panels of some kind. The panels are provided by other modules and can be added by <code>profile:define-panel</code>.</p> <p>You can get a URI pointing to the profile page of a user through the <code>page</code> resource type.</p> <p>The interface also provides access to an &quot;avatar image&quot; to visually identify the user (<code>profile:avatar</code>), a customisable name that the user can change (<code>profile:name</code>), and field types to what kind of data is contained in a user's field and whether it should be public information or not (<code>profile:fields</code> <code>profile:add-field</code> <code>profile:remove-field</code>).</p> <p>See <code>profile:page</code>, <code>profile:avatar</code>, <code>profile:name</code>, <code>profile:fields</code>, <code>profile:add-field</code>, <code>profile:remove-field</code>, <code>profile:list-panels</code>, <code>profile:remove-panel</code>, <code>profile:define-panel</code>, <code>profile:panel</code></p> <h3>2.8 rate</h3> <p>This interface provides for a rate limitation mechanism to prevent spamming or overly eager access to potentially sensitive or costly resources. This happens in two steps. First, the behaviour of the rate limitation is defined for a particular resource by <code>rate:define-limit</code>. Then the resource is protected through the <code>rate:with-limitation</code> macro. If the access to the block by a certain user is too frequent, the block is not called, and the code in the limit definition is evaluated instead.</p> <p>Note that rate limitation is per-client, -user, or -session depending on the implementation, but certainly not global.</p> <p>See <code>rate:define-limit</code>, <code>rate:left</code>, <code>rate:with-limitation</code></p> <h3>2.9 server</h3> <p>This and the logger interface are the only interfaces Radiance requires an implementation for in order to start. It is responsible for accepting and replying to requests in some manner. The implementation must accept requests and relay them to the Radiance <code>request</code> function, and then relay the returned <code>response</code> back to the requester.</p> <p>Note that the actual arguments that specify the listener behaviour are implementation-dependant, as is configuration thereof. However, if applicable, the implementation must provide for a standard listener that is accessible on <code>localhost</code> on the port configured in <code>(mconfig :radiance :port)</code> and is started when <code>radiance:startup</code> is called.</p> <p>See <code>server:start</code>, <code>server:stop</code>, <code>server:listeners</code>, <code>server:started</code>, <code>server:stopped</code></p> <h3>2.10 session</h3> <p>The session interface provides for tracking a client over the course of multiple requests. It however cannot guarantee to track clients perfectly, as they may do several things in order to cloak or mask themselves or falsify information. Still, for most users, the session tracking should work fine enough.</p> <p>The session interface is usually used by other interfaces or lower-lying libraries in order to provide persistence of information such as user authentication.</p> <p>See <code>session:*default-timeout*</code>, <code>session:session</code>, <code>session:=</code>, <code>session:start</code>, <code>session:get</code>, <code>session:list</code>, <code>session:id</code>, <code>session:field</code>, <code>session:timeout</code>, <code>session:end</code>, <code>session:active-p</code>, <code>session:create</code></p> <h3>2.11 user</h3> <p>This interface provides for persistent user objects and a permissions system. It does not take care of authentication, identification, tracking, or anything of the sort. It merely provides a user object upon which to build and with which permissions can be managed.</p> <p>See <code>user:user</code> for a description of permissions and their behaviour.</p> <p>See <code>user:condition</code>, <code>user:not-found</code>, <code>user:user</code>, <code>user:=</code>, <code>user:list</code>, <code>user:get</code>, <code>user:username</code>, <code>user:fields</code>, <code>user:field</code>, <code>user:remove-field</code>, <code>user:remove</code>, <code>user:check</code>, <code>user:grant</code>, <code>user:revoke</code>, <code>user:add-default-permissions</code>, <code>user:action</code>, <code>user:actions</code>, <code>user:create</code>, <code>user:remove</code>, <code>user:action</code>, <code>user:ready</code>, <code>user:unready</code></p> <h2>Also See</h2> <ul> <li><a href="https://shinmera.github.io/modularize">modularize</a> For the primary package metadata system</li> <li><a href="https://shinmera.github.io/modularize-interfaces">modularize-interfaces</a> For the interface and implementations extensions</li> <li><a href="https://shinmera.github.io/modularize-hooks">modularize-hooks</a> For the hooks and triggers mechanisms</li> <li><a href="https://shinmera.github.io/ubiquitous">ubiquitous</a> For configuration management</li> <li><a href="https://shirakumo.org/projects/radiance-contribs">radiance-contribs</a> Default interface implementations and other convenience modules for Radiance</li> </ul> </div>  </article> <article id="copyright">  <h2>Copyright</h2> <span>radiance</span> is licensed under the <span><a href="https://tldrlegal.com/search?q=Artistic">Artistic</a></span> license.  ¬© <span>Nicolas Hafner &lt;shinmera@tymoon.eu&gt;</span> .    </article>  </main> </body> </html> 